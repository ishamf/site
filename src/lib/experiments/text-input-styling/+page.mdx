---
title: Text Input Styling
---

<script lang="ts">
	import CoveredInput from './CoveredInput.svelte';

	let firstValue = 'This is some text inside a text input';
	let secondValue =
		'This looks identical to the above input, but the text inside is rendered differently.';
	let thirdValue =
		'This is some text inside a text input which shows every word with "text" in it in red.' +
		' You can edit the text and it will automatically update.';

	$: transformedThirdValue = thirdValue.split(' ').map((text, i) => ({
		text: i === 0 ? text : ' ' + text,
		style: text.toLowerCase().includes('text') ? 'red' : 'normal',
	}));
</script>

<style>
	input {
		width: 100%;
	}
</style>

# Text Input Styling

Using CSS, we can make the content of text inputs look identical to regular text.

<input
	class="dark:bg-slate-900 p-1"
	bind:value={firstValue}
/>

<p>
	<span class="p-1">{firstValue}</span>
</p>

What if we put the text directly on the input element, and make the actual input text invisible?

<CoveredInput
	bind:value={secondValue}
	rows={2}
>
	{secondValue}
</CoveredInput>

This doesn't look like much now, but we can transform the value before rendering, adding
`&lt;span&gt;`s to style each word differently.

<CoveredInput
	bind:value={thirdValue}
	rows={3}
	>{#each transformedThirdValue as elem}{#if elem.style === 'normal'}{elem.text}{:else}<span
				class="text-red-500">{elem.text}</span
			>{/if}{/each}</CoveredInput
>

This has some caveats though:

- By default, the caret will use the text color (which is transparent in this case)
- You need to carefully manage the whitespace on the rendering element and make sure it perfectly matches the input.
